import { integer } from "aws-sdk/clients/cloudfront";
import type { Schema } from "../../data/resource"
import { DynamoDB } from 'aws-sdk';

const dynamoDb = new DynamoDB.DocumentClient();

const getTopTenArticles = async (type: 'Steel' | 'Auto' | 'Aluminum', count: number) => {
  let allItems: any[] = [];
  let lastEvaluatedKey: any = undefined;
  
  do {
    const params = {
      TableName: 'News-xvm6ipom2jd45jq7boxzeki5bu-NONE',
      IndexName: 'type-lDate-index', // The actual GSI name will be generated by Amplify
      KeyConditionExpression: '#type = :type',
      ExpressionAttributeValues: { ':type': type },
      ExpressionAttributeNames: { '#type': 'type' },
      ScanIndexForward: false, // This gives us lDate DESC
      ...(lastEvaluatedKey && { ExclusiveStartKey: lastEvaluatedKey })
    };
    
    const result = await dynamoDb.query(params).promise();
    
    if (result.Items) {
      allItems = allItems.concat(result.Items);
    }
    
    lastEvaluatedKey = result.LastEvaluatedKey;
    
  } while (lastEvaluatedKey);
  
  // Sort by createdAt for items with same lDate (GSI already sorted by lDate DESC)
  const sortedItems = allItems.sort((a, b) => {
    const dateA = new Date(a.lDate);
    const dateB = new Date(b.lDate);
    const dateDiff = dateB.getTime() - dateA.getTime();
    
    if (dateDiff !== 0) {
      return dateDiff; // lDate DESC (GSI should handle this, but keeping for safety)
    }
    
    // For same lDate, sort by createdAt ASC
    const createdAtA = new Date(a.createdAt);
    const createdAtB = new Date(b.createdAt);
    return createdAtA.getTime() - createdAtB.getTime();
  });
  
  return sortedItems.slice(0, count);
};

// Test the specific format
console.log('Date parsing test:');
console.log(new Date('2025-06-03')); // Should work fine
console.log(new Date('2025-05-28')); // Should work fine

export const handler: Schema["getTopTen"]["functionHandler"] = async (event) => {
  const { type, count = 10 } = event.arguments as { type: 'Steel' | 'Auto' | 'Aluminum', count: integer };
  const actualCount = count ?? 10;
  
  if (type === 'Steel' || type === 'Auto' || type === 'Aluminum') {
    const topTen = await getTopTenArticles(type, actualCount);
    return JSON.stringify(topTen);
  } else {
    throw new Error(`Invalid type: ${type}`);
  }
};